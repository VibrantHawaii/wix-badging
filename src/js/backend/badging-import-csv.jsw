import { mediaManager } from 'wix-media-backend';
import wixData from 'wix-data';
import {fetch} from 'wix-fetch';
import {generateLearnerToken} from 'public/badging-utils'
import {createLearner} from "backend/badging-create-learner";

const HST_TO_UTC_OFFSET = 10*60*60*1000;
const MAGIC_SUPPORTS_WORD = "Supports";

let teachableCourseCSVStruct = {
    "1": {
        "title": "userid",
        "type": undefined
    },
    "2": {
        "title": "fullname",
        "type": "name"
    },
    "3": {
        "title": "email",
        "type": "email"
    },
    "4": {
        "title": "lastlogin",
        "type": undefined
    },
    "5": {
        "title": "joined_at",
        "type": undefined
    },
    "6": {
        "title": "course_count",
        "type": undefined
    },
    "7": {
        "title": "src",
        "type": undefined
    },
    "8": {
        "title": "country",
        "type": undefined
    },
    "9": {
        "title": "sign_in_count",
        "type": undefined
    },
    "10": {
        "title": "unsubscribe_from_marketing_emails",
        "type": undefined
    },
    "11": {
        "title": "affiliate_code",
        "type": undefined
    },
    "12": {
        "title": "billing_address_line",
        "type": undefined
    },
    "13": {
        "title": "billing_address_city",
        "type": undefined
    },
    "14": {
        "title": "billing_address_region",
        "type": undefined
    },
    "15": {
        "title": "billing_address_zipcode",
        "type": undefined
    },
    "16": {
        "title": "billing_address_country",
        "type": undefined
    },
    "17": {
        "title": "delivery_address_line",
        "type": undefined
    },
    "18": {
        "title": "delivery_address_city",
        "type": undefined
    },
    "19": {
        "title": "delivery_address_region",
        "type": undefined
    },
    "20": {
        "title": "delivery_address_zipcode",
        "type": undefined
    },
    "21": {
        "title": "delivery_address_country",
        "type": undefined
    }
};

let offlineClassCSVStruct = {
    "1": {
        "title": "Badge Awarded Date",
        "type": "awardedDate"
    },
    "2": {
        "title": "Badge Expiry Date (if any)",
        "type": "expiryDate"
    },
    "3": {
        "title": "Name",
        "type": "name"
    },
    "4": {
        "title": "Email",
        "type": "email"
    }
    // IMPORTANT All other additional columns are supported regions with type bool
};

let badgrAwardListCSVStruct = {
    "1": {
        "title": "Identifier",
        "type": "email"
    },
    "2": {
        "title": "Recipient Name (optional)",
        "type": "name"
    },
    "3": {
        "title": "Narrative (optional)",
        "type": undefined
    },
    "4": {
        "title": "Evidence URL (optional)",
        "type": undefined
    },
    "5": {
        "title": "Issue Date (optional)",
        "type": "awardedDate"
    },
    "6": {
        "title": "Expiration Date (optional)",
        "type": "expiryDate"
    }
};
let regions = [];

function validateAndImportCSVFileOfAwardedBadges(fileName, badgeRef, CSVStruct, forceAllRegionsSupported, eulaId) {
    let awardedUserDict = {};
    let awardedBadgesDict = {};
    let existingUserResults = {};

    return new Promise((resolve) => {
        resolve(fetchFileFromMediaManager(fileName));
    })
        .then(fileText => validateCSVFormat(fileText, CSVStruct))
        .then(arrayedCSV => createUserDict(arrayedCSV, CSVStruct, badgeRef, forceAllRegionsSupported))
        .then(awardedUserDictResult => {
            awardedUserDict = awardedUserDictResult;
            // Fetch list of all existing learners
            return wixData.query("Badging-Learners")
                .find();
        })
        .then( existingUserResultsResult => {
            existingUserResults = existingUserResultsResult;
            // Tag each awarded learner dict entry as to whether they exist in the User collection yet.
            return existingUserResults.items.map((existingUser) => {
                return existingUser.learnerToken;
            });
        })
        .then(allExistingUsers => {
            return Object.entries(awardedUserDict).map(([id, awardedUser]) => {
                return new Promise((resolve, reject) => {
                    if ((allExistingUsers.includes(awardedUser.learnerToken))) {
                        let existingUser = existingUserResults.items.find(learner => learner.learnerToken == awardedUser.learnerToken);
                        awardedUserDict[awardedUser.learnerToken]._id = existingUser._id;
                        resolve();
                    }
                    else
                    {
                        return createLearner(awardedUser.name,  awardedUser.pii.email, awardedUser.supportsRegions, eulaId)
                            .then(newLearner => {
                                awardedUserDict[awardedUser.learnerToken]._id = newLearner.learner._id;
                                resolve()
                            })
                    }
                })
            })
        })
        .then(newUserCreation => Promise.all(newUserCreation))
        .then(() => mapAwardedUserstoAwardedBadgesDict(awardedUserDict))
        .then((newAwardedBadgesDictResults) => {
            awardedBadgesDict = newAwardedBadgesDictResults;

            return Object.entries(awardedBadgesDict).map(([newAwardedBadgeID, newBadgeAwards]) => {
                // For each badge type awarded
                return new Promise((resolveAward, rejectAward) => {

                    // Query for existing awards
                    return wixData.query("Badging-AwardedBadges")
                        .contains("badgeRef", newAwardedBadgeID)
                        .find()
                        .then(existingBadgeAwards => {
                            const existingAwardedUsers = existingBadgeAwards.items.map(existingAwardedUser => {
                                return existingAwardedUser.learnerRef;
                            });

                            return newBadgeAwards.map((newBadgeAward) => {
                                // For each badge awarded
                                return new Promise((resolve, reject) => {
                                    // For each learner newly awarded the badge
                                    let deleteOldAward = undefined;
                                    if (existingAwardedUsers.find(existingBadgeID => {
                                        return newBadgeAward.learnerRef == existingBadgeID;
                                    })) {
                                        // Consolodate existing awards for matching learnerRefs
                                        // Ruleset: use first awardedDate and newest expiryDate (if any)
                                        const originalAward = existingBadgeAwards.items.find(existingBadge => {
                                            return existingBadge.learnerRef === newBadgeAward.learnerRef;
                                        })

                                        const originalAwardedDate = new Date(originalAward.awardedDate);
                                        // Fixups to translate input dates/times (assumed to be HST) to UTC
                                        const newAwardedDate = new Date(newBadgeAward.awardedDate);
                                        newBadgeAward.awardedDate = originalAwardedDate.getTime() < (new Date(fixUpDateForHST(newAwardedDate))).getTime() ? originalAward.awardedDate :  fixUpDateForHST(newBadgeAward.awardedDate);

                                        deleteOldAward = originalAward._id;
                                    }
                                    else
                                        // Not a match
                                        newBadgeAward.awardedDate = fixUpDateForHST(newBadgeAward.awardedDate);

                                    if (newBadgeAward.expiryDate !== undefined) {
                                        newBadgeAward.expiryDate = fixUpDateForHST(newBadgeAward.expiryDate);
                                    }

                                    const sequenceID = Date.now().toString() + ":" + newAwardedBadgeID.toString() + ":" + newBadgeAward.learnerRef.toString();

                                    // Add award entry
                                    let newAward = {
                                        "title": sequenceID,
                                        "badgeRef": newAwardedBadgeID,
                                        "learnerRef": newBadgeAward.learnerRef,
                                        "awardedDate": new Date(newBadgeAward.awardedDate),
                                        "expiryDate": newBadgeAward.expiryDate
                                    };

                                    return wixData.insert("Badging-AwardedBadges", newAward)
                                        .then( newAward => {
                                            if (deleteOldAward) {
                                                // delete old badge in DB
                                                return wixData.remove("Badging-AwardedBadges", deleteOldAward)
                                                    .then(() => resolve())
                                            }
                                            else
                                                resolve();
                                        })
                                        .catch((error) => {
                                            reject(error);
                                        });
                                });
                            })
                        })
                        .then(badgeIssuance => Promise.all(badgeIssuance))
                        .then(() => resolveAward())
                        .catch((error) => {
                            console.error(error);
                            rejectAward(error);
                        });
                })
            })
        })
        .then(badgeIssuance => Promise.all(badgeIssuance))
        .then(() => {
            return {success: true};
        })
        .catch((error) => {
            console.error(error);
            return {
                "success": false,
                "errorMsg": error.toString()
            };
        });
}

export function importTeachableCourseCSV(fileName, badgeRef, eulaId) {
    return seedRegions()
        .then(() => { return validateAndImportCSVFileOfAwardedBadges(fileName, badgeRef, teachableCourseCSVStruct, true, eulaId)});
}

export function importOfflineClassCSV(fileName, badgeRef, eulaId) {
    return seedRegions()
        .then(() => seedOfflineClassCSVStruct())
        .then(() => { return validateAndImportCSVFileOfAwardedBadges(fileName, badgeRef, offlineClassCSVStruct, false, eulaId)});
}

export function importBadgrAwardListCSV(fileName, badgeRef, eulaId) {
    return seedRegions()
        .then(() => validateAndImportCSVFileOfAwardedBadges(fileName, badgeRef, badgrAwardListCSVStruct, true, eulaId));
}

function fixUpDateForHST(originalDate) {
    let unfixedDate = new Date(originalDate);
    const fixedDateinMS = unfixedDate.getTime() + (HST_TO_UTC_OFFSET);
    return new Date(fixedDateinMS);
}

function mapAwardedUserstoAwardedBadgesDict (awardedUsersDict) {
    let awardedBadgesDict = {};
    Object.entries(awardedUsersDict).map(([id, learnerEntry]) => {
        if (awardedBadgesDict[learnerEntry.award.badgeRef] === undefined)
            awardedBadgesDict[learnerEntry.award.badgeRef] = [];

        awardedBadgesDict[learnerEntry.award.badgeRef].push(
            {
                "foobar": "barfoo",
                "learnerRef": learnerEntry._id,
                "awardedDate": learnerEntry.award.awardedDate,
                "expiryDate": learnerEntry.award.expiryDate
            }
        );
    })
    return awardedBadgesDict;
}

function validateCSVFormat(csvText, structure) {
    return new Promise((resolve, reject) => {
        // Convert csvText to array of arrays
        let arrayedCSV = convertCSVTextToArray(csvText);

        if (arrayedCSV.length < 2) {
            logAndThrowError("No rows found in CSV apart from the header row");
        }

        // test first row (header) length eq struct length (width)
        if (arrayedCSV[0].length != Object.keys(structure).length) {
            logAndThrowError("CSV Validation Error: Header row is " + arrayedCSV[0].length + " columns, it should be " + Object.keys(structure).length);
        }

        // validate first row (header) contents eq struct
        arrayedCSV[0].forEach((csvTitle, index) => {
            if (arrayedCSV[0][index].toUpperCase() != structure[(index + 1) + ""].title.toUpperCase()) {
                logAndThrowError("CSV Validation Error: Header row " + arrayedCSV[0] + " is not identical (including order) to the structure column titles");
            }
        });

        // TODO fix up error handling

        // Delete empty rows
        arrayedCSV = arrayedCSV.filter(currentEntry => {
            return currentEntry.length > 1;
        })

        // Test if all rows have the same number of columns (as the header row)
        if (!arrayedCSV.every((currentEntry) => {
            return arrayedCSV[0].length === currentEntry.length;
        })) {
            logAndThrowError("CSV Validation Error: Not all rows have the correct number of columns (" + arrayedCSV[0].length + ")");
        }

        // Validate each cell entry after first row for type
        // types: date, name, email, bool, undefined
        let orderedTypes = Array.from(Array(arrayedCSV[0].length).keys())
        Object.keys(structure).forEach((key) => {
            orderedTypes[parseInt(key) - 1] = structure[key].type;
        });

        arrayedCSV.every((row, rowIndex) => {
            if (rowIndex !== 0) {
                return row.every((entry, colIndex) => {
                    return validateEntryType(entry, orderedTypes[colIndex], rowIndex, colIndex)
                });
            }

            return true;
        });

        resolve(arrayedCSV);
    })
        .catch( (error) => {
            throw error;
        })
}

// On success returns the text of the (intended CSV) file
function fetchFileFromMediaManager(fileName) {
    return mediaManager.getFileUrl(fileName).then((url) => {
        return fetch(url).then((theFile) => {
            return theFile.text().then((theText) => {
                return(theText);
            });
        });
    })
        .catch((error) => {
            return(error);
        });
}

// Extends the struct with the "Supports <each region name>" members
function seedRegions() {
    return wixData.query("Badging-Regions")
        .ascending("title")
        .find()
        .then( (results) => {
            if (results.length > 0) {
                regions = results.items;
                regions.sort((firstEl, secondEl) => {
                    if ((firstEl.title == "Hāmākua") && (secondEl.title == "Hilo"))
                        return -1;
                    else
                        return 1;
                });
            } else {
                logAndThrowError("Database Error: No regions found!");
            }
        });
}

// Extends the struct with the "Supports <each region name>" members
function seedOfflineClassCSVStruct() {
    if (regions === [])
        seedRegions();

    let originalOfflineClassCSVStructLength = Object.keys(offlineClassCSVStruct).length;
    let nextElementIndex = originalOfflineClassCSVStructLength + 1;

    regions.forEach(region => {
        offlineClassCSVStruct[nextElementIndex] = {
            "title": MAGIC_SUPPORTS_WORD + " " + region.title,
            "type": "bool",
        };
        nextElementIndex++;
    });
}

function logAndThrowError(message) {
    console.error(message);
    throw(Error(message));
}

function validateEntryType(entry, type, rowIndex, colIndex) {
    function failedValidation(entry, type, rowIndex, colIndex) {
        logAndThrowError("Entry \"" + entry + "\" in 1-based row " + (rowIndex + 1) + " and 1-based column " + (colIndex + 1) + " is not of type " + type);
        return false;
    }

    switch (type) {
        case "bool":
            if (!["Yes","No","YES","NO","yes","no","Y","N","y","n", ""].includes(entry))
                return failedValidation(entry, type, rowIndex, colIndex)
            break;

        case "name":
            if (entry.length < 3)
                return failedValidation(entry, type, rowIndex, colIndex)
            break;

        case "email":
            if (entry.length < 3)
                return failedValidation(entry, type, rowIndex, colIndex)
            if (entry.match(/[\w+-_~.]{1,}@[\w+-_~]{1,}\.[\w+-_~]{1,}/) === null)
                return failedValidation(entry, type, rowIndex, colIndex)
            break;

        case "awardedDate":
        case "expiryDate":
            // Example: "7/1/2021"
            if ((entry.match("\\d{1,2}/\\d{1,2}/\\d{4}") === null) &&
                (entry.match("\\d{4}-\\d{1,2}-\\d{1,2}") === null))
                failedValidation(entry, type, rowIndex, colIndex)
            break;

        case undefined:
            break;

        default:
            logAndThrowError("CSV Validation Error: Unknown type requested for validation: " + type)
            return false;
    }
    return true;
}

function createUserDict(csvArray, structure, badgeRef, forceAllRegionsSupported) {
    // Extract key: learner names
    let learnerDict = {};

    function getCSVColumn(type) {
        let columnDict = Object.entries(structure).find(element => element[1].type === type);
        if (columnDict === undefined)
            return undefined;

        let oneIndexedResult = Number(columnDict[0]);
        return oneIndexedResult - 1;
    }

    let awardedDateColumn = getCSVColumn("awardedDate");
    let expiryDateColumn = getCSVColumn("expiryDate");
    let nameColumn = getCSVColumn("name");
    let emailColumn = getCSVColumn("email");

    // Skip header row [0]
    let firstIndexOfSupportedRegion = Object.keys(structure).length - regions.length;
    for (let rowIndex = 1; rowIndex < csvArray.length; rowIndex++) {
        let name = csvArray[rowIndex][nameColumn];

        let supportedRegions = [];
        if (forceAllRegionsSupported) {
            // Force support for all regions
            supportedRegions = regions;
        }
        else {
            supportedRegions = regions.filter((region, index) => {
                let regionColIndexInCSV = firstIndexOfSupportedRegion + index;
                let csvEntry = csvArray[rowIndex][regionColIndexInCSV];
                return boolStringToBool(csvEntry);
            });
        }

        let supportedRegionIDs = supportedRegions.map((region) => {
            return region._id;
        })

        const email = csvArray[rowIndex][emailColumn];
        const learnerToken = generateLearnerToken(name, email);
        const now = new Date();
        const nowString = now.toDateString();

        let awardedDate = nowString;
        if (awardedDateColumn != undefined)
            awardedDate = csvArray[rowIndex][awardedDateColumn];

        let expiryDate = undefined;
        if (expiryDateColumn != undefined)
            expiryDate = csvArray[rowIndex][expiryDateColumn];

        learnerDict[learnerToken] = {
            'name': name,
            'learnerToken': learnerToken,
            'pii': {
                'email': email,
            },
            'award': {
                'badgeRef': badgeRef,
                'awardedDate': awardedDate,
                'expiryDate': expiryDate,
            },
            'supportsRegions': supportedRegionIDs
        };
    }

    return learnerDict;
}

function boolStringToBool(target) {
    return ["Yes","YES","yes","Y","y"].includes(target);
}

function convertCSVTextToArray(csvText) {
    let linedCSV = csvText.split("\n");
    let arrayedCSV = [];
    linedCSV.forEach(element => {
        arrayedCSV.push(element.replace(/[\n\r]+/g, '').trim().split(","))
    });
    return arrayedCSV;
}